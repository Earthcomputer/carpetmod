--- ../src-base/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
+++ ../src-work/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
@@ -1,14 +1,15 @@
 package net.minecraft.world.chunk.storage;
 
-import com.google.common.collect.Maps;
+import carpet.utils.UnloadOrder;
+import com.google.common.collect.Maps; //CM unused import
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
-import java.util.Collections;
+import java.util.Collections; //CM unused import
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
+import java.util.Set; //CM unused import
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.entity.Entity;
@@ -24,9 +25,11 @@
 import net.minecraft.util.datafix.IDataWalker;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.MinecraftException;
 import net.minecraft.world.NextTickListEntry;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldServerMulti;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.NibbleArray;
 import net.minecraft.world.storage.IThreadedFileIO;
@@ -34,12 +37,78 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import java.util.HashMap;
+import java.util.Iterator;
+import carpet.CarpetSettings;
+
+import java.util.Collections;
+
 public class AnvilChunkLoader implements IChunkLoader, IThreadedFileIO
 {
     private static final Logger field_151505_a = LogManager.getLogger();
-    private final Map<ChunkPos, NBTTagCompound> field_75828_a = Maps.<ChunkPos, NBTTagCompound>newConcurrentMap();
-    private final Set<ChunkPos> field_193415_c = Collections.<ChunkPos>newSetFromMap(Maps.newConcurrentMap());
-    private final File field_75825_d;
+    //CM removed old structures
+    //private final Map<ChunkPos, NBTTagCompound> chunksToRemove = Maps.<ChunkPos, NBTTagCompound>newConcurrentMap();
+    //private final Set<ChunkPos> chunksBeingSaved = Collections.<ChunkPos>newSetFromMap(Maps.newConcurrentMap());
+    //CM added new stuctures that will be managed separately
+    private final Map<ChunkPos, NBTTagCompound> savestatedChunksToSave = new HashMap<>();
+    private final Map<ChunkPos, NBTTagCompound> field_75828_a = new HashMap();
+    private final Map<ChunkPos, NBTTagCompound> chunksInWrite = new HashMap();
+    // Insert new chunk into pending queue, replacing any older one at the same position
+    synchronized private void queueChunkToRemove(ChunkPos pos, NBTTagCompound data)
+    {
+        if (UnloadOrder.isLargeEnoughToSavestate(UnloadOrder.getSavedChunkSize(data))) {
+            savestatedChunksToSave.put(pos, data);
+        } else {
+            field_75828_a.put(pos, data);
+        }
+    }
+    // Fetch another chunk to save to disk and atomically move it into
+    // the queue of chunk(s) being written.
+    synchronized private Map.Entry<ChunkPos, NBTTagCompound> fetchChunkToWrite()
+    {
+        if (!savestatedChunksToSave.isEmpty()) {
+            Iterator<Map.Entry<ChunkPos, NBTTagCompound>> iter = savestatedChunksToSave.entrySet().iterator();
+            Map.Entry<ChunkPos, NBTTagCompound> entry = iter.next();
+            iter.remove();
+            chunksInWrite.put(entry.getKey(), entry.getValue());
+            return entry;
+        }
+        if (field_75828_a.isEmpty()) return null;
+        Iterator<Map.Entry<ChunkPos, NBTTagCompound>> iter =
+                field_75828_a.entrySet().iterator();
+        Map.Entry<ChunkPos, NBTTagCompound> entry = iter.next();
+        iter.remove();
+        chunksInWrite.put(entry.getKey(), entry.getValue());
+        return entry;
+    }
+
+    // Once the write for a chunk is completely committed to disk,
+    // this method discards it
+    synchronized private void retireChunkToWrite(ChunkPos pos, NBTTagCompound data)
+    {
+        chunksInWrite.remove(pos);
+    }
+
+    // Check these data structures for a chunk being reloaded
+    synchronized private NBTTagCompound reloadChunkFromRemoveQueues(ChunkPos pos)
+    {
+        NBTTagCompound data = savestatedChunksToSave.get(pos);
+        if (data != null) return data;
+        data = field_75828_a.get(pos);
+        if (data != null) return data;
+        return (CarpetSettings.entityDuplicationFix)?chunksInWrite.get(pos):data;
+    }
+
+    // Check if chunk exists at all in any pending save state
+    //synchronized private boolean chunkExistInRemoveQueues(ChunkPos pos)
+    //{
+    //    return chunksToRemove.containsKey(pos) || chunksInWrite.containsKey(pos);
+    //}
+
+    /* --- end of new code for MC-119971 --- */
+
+
+    public final File field_75825_d; // CM changed to public for ticking areas
     private final DataFixer field_193416_e;
     private boolean field_183014_e;
 
@@ -53,7 +122,8 @@
     public Chunk func_75815_a(World p_75815_1_, int p_75815_2_, int p_75815_3_) throws IOException
     {
         ChunkPos chunkpos = new ChunkPos(p_75815_2_, p_75815_3_);
-        NBTTagCompound nbttagcompound = this.field_75828_a.get(chunkpos);
+        //NBTTagCompound nbttagcompound = this.chunksToRemove.get(chunkpos);
+        NBTTagCompound nbttagcompound = reloadChunkFromRemoveQueues(chunkpos);  // new for MC-119971
 
         if (nbttagcompound == null)
         {
@@ -73,7 +143,10 @@
     public boolean func_191063_a(int p_191063_1_, int p_191063_2_)
     {
         ChunkPos chunkpos = new ChunkPos(p_191063_1_, p_191063_2_);
-        NBTTagCompound nbttagcompound = this.field_75828_a.get(chunkpos);
+        //CM
+        //NBTTagCompound nbttagcompound = this.chunksToRemove.get(chunkpos);
+        NBTTagCompound nbttagcompound = reloadChunkFromRemoveQueues(chunkpos);
+        //
         return nbttagcompound != null ? true : RegionFileCache.func_191064_f(this.field_75825_d, p_191063_1_, p_191063_2_);
     }
 
@@ -132,37 +205,63 @@
 
     protected void func_75824_a(ChunkPos p_75824_1_, NBTTagCompound p_75824_2_)
     {
-        if (!this.field_193415_c.contains(p_75824_1_))
+        //CM extended condition to mimic vanilla better
+        //if (!this.chunksBeingSaved.contains(pos))
+        //{
+        //    this.chunksToRemove.put(pos, compound);
+        //}
+        if ( CarpetSettings.entityDuplicationFix || !chunksInWrite.containsKey(p_75824_1_))
         {
-            this.field_75828_a.put(p_75824_1_, p_75824_2_);
+            queueChunkToRemove(p_75824_1_, p_75824_2_);
         }
 
+
         ThreadedFileIOBase.func_178779_a().func_75735_a(this);
     }
 
     public boolean func_75814_c()
     {
-        if (this.field_75828_a.isEmpty())
+/*        if (this.chunksToRemove.isEmpty())
         {
-            if (this.field_183014_e)
+            if (this.savingExtraData)
             {
-                field_151505_a.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.field_75825_d.getName());
+                LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.chunkSaveLocation.getName());
             }
 
             return false;
         }
         else
         {
-            ChunkPos chunkpos = this.field_75828_a.keySet().iterator().next();
-            boolean lvt_3_1_;
+            */
 
-            try
-            {
-                this.field_193415_c.add(chunkpos);
-                NBTTagCompound nbttagcompound = this.field_75828_a.remove(chunkpos);
+            //ChunkPos chunkpos = this.chunksToRemove.keySet().iterator().next();
 
-                if (nbttagcompound != null)
+            Map.Entry<ChunkPos, NBTTagCompound> entry = fetchChunkToWrite();
+            if (entry == null) {
+                // If none left, here's code for some message that will never
+                // be executed since there is no "extra data."
+                if (this.field_183014_e)
                 {
+                    field_151505_a.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", new Object[] {this.field_75825_d.getName()});
+                }
+
+                return false;
+            }
+
+            // New for MC-119971
+            ChunkPos chunkpos = entry.getKey();
+            NBTTagCompound nbttagcompound = entry.getValue();
+
+
+            //boolean lvt_3_1_;
+
+            //try
+            //{
+            //   this.chunksBeingSaved.add(chunkpos);
+            //    NBTTagCompound nbttagcompound = this.chunksToRemove.remove(chunkpos);
+
+            //    if (nbttagcompound != null)
+            //    {
                     try
                     {
                         this.func_183013_b(chunkpos, nbttagcompound);
@@ -171,17 +270,19 @@
                     {
                         field_151505_a.error("Failed to save chunk", (Throwable)exception);
                     }
-                }
+             //   }
 
-                lvt_3_1_ = true;
-            }
-            finally
-            {
-                this.field_193415_c.remove(chunkpos);
-            }
+            //    lvt_3_1_ = true;
+            //}
+            //finally
+            //{
+            //    this.chunksBeingSaved.remove(chunkpos);
+            //}
+            retireChunkToWrite(chunkpos, nbttagcompound);
 
-            return lvt_3_1_;
-        }
+            //return lvt_3_1_;
+            return true;
+        //} //CM fixed indentation
     }
 
     private void func_183013_b(ChunkPos p_183013_1_, NBTTagCompound p_183013_2_) throws IOException
@@ -249,7 +350,8 @@
         });
     }
 
-    private void func_75820_a(Chunk p_75820_1_, World p_75820_2_, NBTTagCompound p_75820_3_)
+    // CM: change access to public & static
+    public static void func_75820_a(Chunk p_75820_1_, World p_75820_2_, NBTTagCompound p_75820_3_)
     {
         p_75820_3_.func_74768_a("xPos", p_75820_1_.field_76635_g);
         p_75820_3_.func_74768_a("zPos", p_75820_1_.field_76647_h);
@@ -295,6 +397,10 @@
         }
 
         p_75820_3_.func_74782_a("Sections", nbttaglist);
+        // NewLight PHIPRO-CARPET
+        //if(CarpetSettings.newLight){
+        //	carpet.helpers.LightingHooks.writeLightData(chunkIn, compound);
+        //}
         p_75820_3_.func_74773_a("Biomes", p_75820_1_.func_76605_m());
         p_75820_1_.func_177409_g(false);
         NBTTagList nbttaglist1 = new NBTTagList();
@@ -383,6 +489,11 @@
 
         chunk.func_76602_a(aextendedblockstorage);
 
+        // NewLight PHIPRO-CARPET
+        //if(CarpetSettings.newLight){
+        //	carpet.helpers.LightingHooks.readLightData(chunk, compound);
+        //}
+
         if (p_75823_2_.func_150297_b("Biomes", 7))
         {
             chunk.func_76616_a(p_75823_2_.func_74770_j("Biomes"));
@@ -428,7 +539,9 @@
                     block = Block.func_149729_e(nbttagcompound3.func_74762_e("i"));
                 }
 
-                p_75823_1_.func_180497_b(new BlockPos(nbttagcompound3.func_74762_e("x"), nbttagcompound3.func_74762_e("y"), nbttagcompound3.func_74762_e("z")), block, nbttagcompound3.func_74762_e("t"), nbttagcompound3.func_74762_e("p"));
+                BlockPos pos = new BlockPos(nbttagcompound3.func_74762_e("x"), nbttagcompound3.func_74762_e("y"), nbttagcompound3.func_74762_e("z"));
+                System.out.println("Tick " + p_75823_1_.func_73046_m().func_71259_af() % 900 + ": loading tile tick at " + pos.func_177958_n() + ", " + pos.func_177956_o() + ", " + pos.func_177952_p() + " of " + Block.field_149771_c.func_177774_c(block) + " with delay " + nbttagcompound3.func_74762_e("t"));
+                p_75823_1_.func_180497_b(pos, block, nbttagcompound3.func_74762_e("t"), nbttagcompound3.func_74762_e("p"));
             }
         }
 
@@ -482,7 +595,9 @@
 
             if (p_186054_8_ && !p_186054_1_.func_72838_d(entity))
             {
-                return null;
+                p_186054_1_.func_72964_e(MathHelper.func_76128_c(p_186054_2_ / 16), MathHelper.func_76128_c(p_186054_6_ / 16)).func_76612_a(entity);
+                p_186054_1_.func_175650_b(Collections.singletonList(entity));
+                return entity;
             }
             else
             {
